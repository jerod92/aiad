"""
Synthetic dataset for supervised pre-training.

Generates random shapes via the ``aiad.shapes`` package, simulates a random
mid-drawing state, and provides the correct next action as the training target.

The target raster image is generated by replaying ALL actions in the sequence
using the same ``_replay_actions`` logic used for partial drawings.  This
guarantees perfect visual consistency between what the model sees as the
"target" and what it would produce by following the action sequence correctly.

Supports both *large* (512 px) and *mini* (256 px) image sizes.
"""

import numpy as np
import torch
from torch.utils.data import Dataset

from aiad.config import TOOL_MAP, IMG_SIZE
from aiad.raster import (
    rasterize_line, rasterize_circle, rasterize_rectangle,
    rasterize_ellipse, rasterize_bezier, rasterize_arc,
    rasterize_regular_polygon, draw_cursor_np, gaussian_blur,
    rasterize_construction_line, rasterize_fillet_arc,
    rasterize_chamfer, rasterize_offset_line, mirror_layer,
    erase_rectangle,
)
from aiad.shapes import ALL_GENERATORS, random_shape, ShapeSample, ActionStep


class MixedShapeDataset(Dataset):
    """On-the-fly generator of supervised training samples.

    Each sample contains:
      obs          [6, H, W] — target (3ch) + drawing + ghost + cursor
      prev_tool    long       — tool index at the current state
      prev_click   float      — whether the previous action was a click
      target_x     long       — correct next X position
      target_y     long       — correct next Y position
      target_tool  long       — correct next tool
      target_click float      — whether the next action should click
      target_snap  float      — whether the next action should snap
      target_end   float      — whether the drawing should end after this action
    """

    def __init__(self, num_samples=16_000, img_size=IMG_SIZE):
        self.num_samples = num_samples
        self.img_size = img_size

    def __len__(self):
        return self.num_samples

    # ------------------------------------------------------------------
    # Main entry
    # ------------------------------------------------------------------

    def __getitem__(self, idx):
        shape = random_shape(self.img_size)
        return self._simulate_mid_drawing(shape)

    # ------------------------------------------------------------------
    # Simulate a mid-drawing state
    # ------------------------------------------------------------------

    def _simulate_mid_drawing(self, shape: ShapeSample):
        """Pick a random point in the action sequence and build a training
        sample from that partial state.

        The target raster is built by replaying ALL actions so it is
        guaranteed to match what the drawing would look like at completion.
        """
        S = self.img_size
        actions = shape.actions
        n_actions = len(actions)

        if n_actions == 0:
            return self._fallback_line()

        # --- Choose step index (more uniform coverage) ---
        # 25% step 0, 50% random middle, 25% final step
        if n_actions <= 2:
            step_idx = 0 if np.random.rand() < 0.5 else n_actions - 1
        else:
            r = np.random.rand()
            if r < 0.25:
                step_idx = 0
            elif r < 0.75:
                step_idx = np.random.randint(1, n_actions - 1) if n_actions > 2 else 1
            else:
                step_idx = n_actions - 1

        target_action = actions[step_idx]

        # --- Build the drawing state by replaying actions 0..step_idx-1 ---
        drawing = np.zeros((S, S), dtype=np.float32)
        ghost = np.zeros((S, S), dtype=np.float32)
        prev_tool = TOOL_MAP["None"]
        prev_click = 0.0

        if step_idx > 0:
            drawing = self._replay_actions(actions[:step_idx], S)
            prev_tool = actions[step_idx - 1].tool
            prev_click = actions[step_idx - 1].click

        # --- Generate target by replaying ALL actions (consistency fix) ---
        target_layer = self._replay_actions(actions, S)
        target_layer = gaussian_blur(target_layer)

        # --- Random visual variety for the target raster ---
        bg_val, line_val = self._random_appearance()
        target_display = np.full((S, S), bg_val, dtype=np.float32)
        mask = target_layer > 0.05
        target_display[mask] = line_val

        # Sometimes use dashed appearance for target
        if np.random.rand() < 0.15:
            # Simulate dashed by randomly zeroing small segments
            dash_mask = np.random.rand(S, S) > 0.35
            target_display[mask & dash_mask] = bg_val
            target_display[mask & ~dash_mask] = line_val

        target_rgb = np.stack([target_display] * 3, axis=0)

        # --- Ghost line from last anchor to random cursor pos ---
        cursor = np.zeros((S, S), dtype=np.float32)
        cx, cy = np.random.randint(0, S, 2)
        draw_cursor_np(cursor, cx, cy)

        if step_idx > 0 and actions[step_idx - 1].click > 0.5:
            last = actions[step_idx - 1]
            rasterize_line(ghost, (last.x, last.y), (cx, cy), 0.4, 1)

        return self._pack(
            target_rgb, drawing, ghost, cursor,
            prev_tool=prev_tool, prev_click=prev_click,
            tx=int(np.clip(target_action.x, 0, S - 1)),
            ty=int(np.clip(target_action.y, 0, S - 1)),
            ttool=target_action.tool,
            tclick=target_action.click,
            tsnap=target_action.snap,
            tend=target_action.end,
        )

    # ------------------------------------------------------------------
    # Random appearance for target raster
    # ------------------------------------------------------------------

    @staticmethod
    def _random_appearance():
        """Return (bg_value, line_value) for random visual variety."""
        r = np.random.rand()
        if r < 0.5:
            # Dark lines on light bg (most common CAD style)
            bg = np.random.uniform(0.0, 0.15)
            line = np.random.uniform(0.7, 1.0)
        elif r < 0.8:
            # Light lines on dark bg (blueprint style)
            bg = np.random.uniform(0.0, 0.1)
            line = np.random.uniform(0.5, 0.9)
        else:
            # Mid-range contrast
            bg = np.random.uniform(0.1, 0.3)
            line = np.random.uniform(0.6, 1.0)
        return float(bg), float(line)

    # ------------------------------------------------------------------
    # Replay actions to build drawing state
    # ------------------------------------------------------------------

    def _replay_actions(self, actions, S):
        """Rasterise completed actions onto a drawing layer.

        This is the single source of truth for how an action sequence
        translates into pixels.  Both the target image and the partial
        drawing are generated through this function.
        """
        drawing = np.zeros((S, S), dtype=np.float32)
        line_start = None
        polyline_start = None
        rect_start = None
        arc_pts = []
        circle_center = None
        ellipse_pts = []
        regpoly_center = None
        spline_pts = []
        # New tool state
        mirror_axis_start = None
        offset_pts = []
        fillet_pts = []
        chamfer_start = None
        trim_start = None
        constr_pts = []

        prev_tool = None

        for a in actions:
            pos = (a.x, a.y)

            # --- Tool switch: reset all active state ---
            if prev_tool is not None and a.tool != prev_tool:
                line_start = None
                polyline_start = None
                rect_start = None
                arc_pts = []
                circle_center = None
                ellipse_pts = []
                regpoly_center = None
                if spline_pts and len(spline_pts) >= 2:
                    rasterize_bezier(drawing, spline_pts, 1.0, 2)
                spline_pts = []
                mirror_axis_start = None
                offset_pts = []
                fillet_pts = []
                chamfer_start = None
                trim_start = None
                constr_pts = []

            prev_tool = a.tool

            # --- None tool: explicit reset ---
            if a.tool == TOOL_MAP["None"]:
                line_start = None
                polyline_start = None
                rect_start = None
                arc_pts = []
                circle_center = None
                ellipse_pts = []
                regpoly_center = None
                spline_pts = []
                mirror_axis_start = None
                offset_pts = []
                fillet_pts = []
                chamfer_start = None
                trim_start = None
                constr_pts = []
                continue

            if a.click < 0.5:
                continue

            tool = a.tool

            if tool == TOOL_MAP["Line"]:
                if line_start is not None:
                    end_pt = polyline_start if (a.snap > 0.5 and polyline_start) else pos
                    rasterize_line(drawing, line_start, end_pt, 1.0, 2)
                    if a.snap > 0.5:
                        line_start = None
                        polyline_start = None
                    else:
                        line_start = end_pt
                else:
                    line_start = pos
                    polyline_start = pos

            elif tool == TOOL_MAP["Circle"]:
                if circle_center is None:
                    circle_center = pos
                else:
                    r = np.linalg.norm(np.array(pos) - np.array(circle_center))
                    rasterize_circle(drawing, circle_center, r, 1.0, 2)
                    circle_center = None

            elif tool == TOOL_MAP["Rectangle"]:
                if rect_start is None:
                    rect_start = pos
                else:
                    rasterize_rectangle(drawing, rect_start, pos, 1.0, 2)
                    rect_start = None

            elif tool == TOOL_MAP["Arc"]:
                arc_pts.append(pos)
                if len(arc_pts) == 3:
                    rasterize_arc(drawing, arc_pts[0], arc_pts[1], arc_pts[2], 1.0, 2)
                    arc_pts = []

            elif tool == TOOL_MAP["Ellipse"]:
                ellipse_pts.append(pos)
                if len(ellipse_pts) == 3:
                    c = ellipse_pts[0]
                    ep_a = ellipse_pts[1]
                    ep_b = ellipse_pts[2]
                    a_len = np.sqrt((ep_a[0] - c[0]) ** 2 + (ep_a[1] - c[1]) ** 2)
                    b_len = np.sqrt((ep_b[0] - c[0]) ** 2 + (ep_b[1] - c[1]) ** 2)
                    angle = np.degrees(np.arctan2(ep_a[1] - c[1], ep_a[0] - c[0]))
                    rasterize_ellipse(drawing, c, (a_len, b_len), angle, 1.0, 2)
                    ellipse_pts = []

            elif tool == TOOL_MAP["RegPolygon"]:
                if regpoly_center is None:
                    regpoly_center = pos
                else:
                    r = np.linalg.norm(np.array(pos) - np.array(regpoly_center))
                    angle_off = np.arctan2(pos[1] - regpoly_center[1],
                                           pos[0] - regpoly_center[0])
                    n_sides = a.sides if a.sides >= 3 else 6
                    rasterize_regular_polygon(drawing, regpoly_center, r, n_sides,
                                              angle_off, 1.0, 2)
                    regpoly_center = None

            elif tool == TOOL_MAP["Spline"]:
                spline_pts.append(pos)
                if a.snap > 0.5 or a.end > 0.5:
                    if len(spline_pts) >= 2:
                        rasterize_bezier(drawing, spline_pts, 1.0, 2)
                    spline_pts = []

            elif tool == TOOL_MAP["Mirror"]:
                if mirror_axis_start is None:
                    mirror_axis_start = pos
                else:
                    drawing = mirror_layer(drawing, mirror_axis_start, pos)
                    mirror_axis_start = None

            elif tool == TOOL_MAP["Offset"]:
                offset_pts.append(pos)
                if len(offset_pts) == 3:
                    rasterize_offset_line(drawing, offset_pts[0], offset_pts[1],
                                          offset_pts[2], 1.0, 2)
                    offset_pts = []

            elif tool == TOOL_MAP["Fillet"]:
                fillet_pts.append(pos)
                if len(fillet_pts) == 3:
                    corner = fillet_pts[0]
                    pt_a = fillet_pts[1]
                    pt_b = fillet_pts[2]
                    radius = np.linalg.norm(
                        np.array(pt_b) - np.array(corner)) * 0.5
                    rasterize_fillet_arc(drawing, corner, pt_a, pt_b,
                                         max(radius, 5), 1.0, 2)
                    fillet_pts = []

            elif tool == TOOL_MAP["Chamfer"]:
                if chamfer_start is None:
                    chamfer_start = pos
                else:
                    rasterize_chamfer(drawing, chamfer_start, pos, 1.0, 2)
                    chamfer_start = None

            elif tool == TOOL_MAP["Trim"]:
                # Trim/subtract: two clicks define an erase rectangle
                if trim_start is None:
                    trim_start = pos
                else:
                    erase_rectangle(drawing, trim_start, pos)
                    trim_start = None

            elif tool == TOOL_MAP["ConstrLine"]:
                constr_pts.append(pos)
                if len(constr_pts) == 2:
                    rasterize_construction_line(drawing, constr_pts[0], constr_pts[1],
                                                0.5, 1)
                    constr_pts = []

        return drawing

    # ------------------------------------------------------------------
    # Fallback
    # ------------------------------------------------------------------

    def _fallback_line(self):
        S = self.img_size
        m = 30
        p1 = np.random.randint(m, S - m, 2)
        p2 = np.random.randint(m, S - m, 2)
        target = np.zeros((S, S), dtype=np.float32)
        rasterize_line(target, p1, p2, 1.0, 2)
        target = gaussian_blur(target)
        target_rgb = np.stack([target] * 3, axis=0)
        drawing = np.zeros((S, S), dtype=np.float32)
        ghost = np.zeros((S, S), dtype=np.float32)
        cursor = np.zeros((S, S), dtype=np.float32)
        cx, cy = np.random.randint(0, S, 2)
        draw_cursor_np(cursor, cx, cy)
        return self._pack(
            target_rgb, drawing, ghost, cursor,
            prev_tool=TOOL_MAP["None"], prev_click=0.0,
            tx=int(p1[0]), ty=int(p1[1]),
            ttool=TOOL_MAP["Line"], tclick=1.0, tsnap=0.0, tend=0.0,
        )

    # ------------------------------------------------------------------
    # Pack sample
    # ------------------------------------------------------------------

    def _pack(self, target_rgb, drawing, ghost, cursor, *,
              prev_tool, prev_click, tx, ty, ttool, tclick, tsnap, tend):
        obs = np.concatenate([
            target_rgb,
            drawing[np.newaxis],
            ghost[np.newaxis],
            cursor[np.newaxis],
        ], axis=0)
        return {
            "obs": torch.from_numpy(obs),
            "prev_tool": torch.tensor(prev_tool, dtype=torch.long),
            "prev_click": torch.tensor(prev_click, dtype=torch.float32),
            "target_x": torch.tensor(tx, dtype=torch.long),
            "target_y": torch.tensor(ty, dtype=torch.long),
            "target_tool": torch.tensor(ttool, dtype=torch.long),
            "target_click": torch.tensor(tclick, dtype=torch.float32),
            "target_snap": torch.tensor(tsnap, dtype=torch.float32),
            "target_end": torch.tensor(tend, dtype=torch.float32),
        }
